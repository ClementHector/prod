"""
Environment variable management for the Prod CLI tool.

This module provides functionality for managing environment variables and
generating shell scripts for different platforms.
"""

import os
import platform
import tempfile
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, List, Optional, TextIO

from src.exceptions import EnvironmentError
from src.logger import get_logger

# Constants for shell script generation
PROD_CLI_HEADER = "# Generated by Prod CLI\n"
PROD_CLI_ENV_SETUP = "# This script sets up the environment for the production\n\n"
PROD_CLI_INTERACTIVE_SETUP = "# This script sets up an interactive production environment\n\n"


class ScriptWriter(ABC):
    """
    Abstract base class for writing specific sections of shell scripts.
    """

    @abstractmethod
    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write content to the given file.

        Args:
            file: File object to write to
            **kwargs: Additional parameters needed for writing
        """
        pass


class HeaderWriter(ScriptWriter):
    """
    Writes the script header.
    """

    @abstractmethod
    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write the script header.

        Args:
            file: File object to write to
            **kwargs: Should include 'prod_name'
        """
        if "prod_name" not in kwargs:
            raise EnvironmentError("Production name is required for header")


class EnvironmentSetupWriter(ScriptWriter):
    """
    Writes environment variable setup.
    """

    def __init__(self, env_variables: Dict[str, str]):
        """
        Initialize with environment variables.

        Args:
            env_variables: Environment variables to be set
        """
        self.env_variables = env_variables

    @abstractmethod
    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write environment setup code.

        Args:
            file: File object to write to
        """
        pass


class SoftwareAliasWriter(ScriptWriter):
    """
    Writes software aliases.
    """

    @abstractmethod
    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write software aliases.

        Args:
            file: File object to write to
            **kwargs: Should include 'software_items' and 'prod_name'
        """
        if "software_items" not in kwargs:
            raise EnvironmentError("Software items are required for aliases")
        if "prod_name" not in kwargs:
            raise EnvironmentError("Production name is required for software aliases")

    def _get_prod_launch_path(self) -> str:
        """
        Get the path to the prod-launch script.

        Returns:
            Path to the prod-launch script
        """
        prod_launch_path = Path(__file__).parent.parent / "prod-launch.py"
        if not prod_launch_path.exists():
            raise EnvironmentError(f"prod-launch.py script not found at {prod_launch_path}")
        return str(prod_launch_path)

    def _command(self, software_name: str) -> str:
        """
        Generate the command for launching the software.

        Args:
            software_name: Name of the software

        Returns:
            Command string
        """
        return f"python {self._get_prod_launch_path()} {software_name} --prod {self.prod_name}"


class WelcomeMessageWriter(ScriptWriter):
    """
    Writes welcome message.
    """

    @abstractmethod
    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write welcome message.

        Args:
            file: File object to write to
            **kwargs: Should include 'prod_name' and 'software_items'
        """
        if "prod_name" not in kwargs or "software_items" not in kwargs:
            raise EnvironmentError(
                "Production name and software items required for welcome message"
            )


class ShellScriptGenerator(ABC):
    """
    Abstract base class for shell script generation.

    This class uses the Template Method pattern to define the skeleton of the script
    generation algorithm, with concrete subclasses implementing platform-specific details.
    """

    def __init__(self, env_variables: Dict[str, str]):
        """
        Initialize the shell script generator.

        Args:
            env_variables: Environment variables to include in scripts
        """
        self.env_variables = env_variables
        self.logger = get_logger()

        # Initialize the component writers
        self.header_writer = self._create_header_writer()
        self.env_setup_writer = self._create_env_setup_writer(env_variables)
        self.software_alias_writer = self._create_software_alias_writer()
        self.welcome_msg_writer = self._create_welcome_msg_writer()

    @abstractmethod
    def _create_header_writer(self) -> HeaderWriter:
        """
        Create the appropriate header writer.

        Returns:
            HeaderWriter implementation
        """
        pass

    @abstractmethod
    def _create_env_setup_writer(
        self, env_variables: Dict[str, str]
    ) -> EnvironmentSetupWriter:
        """
        Create the appropriate environment setup writer.

        Args:
            env_variables: Environment variables to be set

        Returns:
            EnvironmentSetupWriter implementation
        """
        pass

    @abstractmethod
    def _create_software_alias_writer(self) -> SoftwareAliasWriter:
        """
        Create the appropriate software alias writer.

        Returns:
            SoftwareAliasWriter implementation
        """
        pass

    @abstractmethod
    def _create_welcome_msg_writer(self) -> WelcomeMessageWriter:
        """
        Create the appropriate welcome message writer.

        Returns:
            WelcomeMessageWriter implementation
        """
        pass

    @abstractmethod
    def _get_file_extension(self) -> str:
        """
        Get the file extension for the script.

        Returns:
            File extension string (e.g., '.sh', '.ps1')
        """
        pass

    def generate_interactive_script(
        self, prod_name: str, software_list: Optional[List[str]] = None
    ) -> str:
        """
        Generate an interactive shell script with custom environment.

        This method implements the Template Method pattern, defining the
        algorithm skeleton while delegating specific implementations to subclasses.

        Args:
            prod_name: Name of the production
            software_list: Optional list of software items in format "name:version"

        Returns:
            Path to the generated script
        """
        script_dir = self._ensure_script_directory()
        script_path = os.path.join(
            script_dir, f"prod_interactive_{prod_name}{self._get_file_extension()}"
        )

        try:
            with open(script_path, "w") as f:
                # Use the component writers to generate script sections
                self.header_writer.write(f, prod_name=prod_name)
                self.env_setup_writer.write(f)

                software_items = self._get_software_items(software_list)
                self.software_alias_writer.write(
                    f, prod_name=prod_name, software_items=software_items
                )
                self.welcome_msg_writer.write(
                    f, prod_name=prod_name, software_items=software_items
                )

            self._set_file_permissions(script_path)
            self.logger.debug(f"Generated interactive script: {script_path}")
            return script_path

        except Exception as e:
            raise EnvironmentError(f"Failed to generate interactive script: {e}")

    def _set_file_permissions(self, script_path: str) -> None:
        """
        Set executable permissions for scripts.

        Args:
            script_path: Path to the script
        """
        os.chmod(script_path, 0o755)

    def _ensure_script_directory(self) -> str:
        """
        Ensure the script directory exists and return its path.

        Returns:
            Path to the script directory
        """
        script_dir = Path(tempfile.gettempdir()) / "prod_cli"
        os.makedirs(script_dir, exist_ok=True)
        return script_dir

    def _get_software_items(
        self, software_list: Optional[List[str]] = None
    ) -> List[str]:
        """
        Get the list of software items from either the provided list or environment variables.

        Args:
            software_list: Optional list of software items

        Returns:
            List of software items
        """
        if software_list:
            return software_list

        software_list_var = self.env_variables.get("SOFTWARE_LIST", "")
        if software_list_var:
            return software_list_var.split(";")

        return []


class PowerShellScriptGenerator(ShellScriptGenerator):
    """
    PowerShell script generator implementation.
    """

    def _create_header_writer(self) -> HeaderWriter:
        return PowerShellHeaderWriter()

    def _create_env_setup_writer(
        self, env_variables: Dict[str, str]
    ) -> EnvironmentSetupWriter:
        return PowerShellEnvironmentSetupWriter(env_variables)

    def _create_software_alias_writer(self) -> SoftwareAliasWriter:
        return PowerShellSoftwareAliasWriter()

    def _create_welcome_msg_writer(self) -> WelcomeMessageWriter:
        return PowerShellWelcomeMessageWriter()

    def _get_file_extension(self) -> str:
        return ".ps1"


class PowerShellHeaderWriter(HeaderWriter):
    """
    PowerShell script header writer.
    """

    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write the PowerShell script header.

        Args:
            file: File object to write to
            **kwargs: Should include 'prod_name'
        """
        prod_name = kwargs["prod_name"]

        file.write(PROD_CLI_HEADER)
        file.write(PROD_CLI_INTERACTIVE_SETUP)

        # Check for verbose mode
        file.write("# Check for verbose mode\n")
        file.write("$script:VERBOSE = $false\n")
        file.write("if ($VerbosePreference -eq 'Continue') {\n")
        file.write("    $script:VERBOSE = $true\n")
        file.write("    Write-Host 'Verbose mode enabled' -ForegroundColor Cyan\n")
        file.write("}\n\n")

        file.write("function global:prompt {\n")
        file.write(f'    "[PROD:{prod_name}] $(Get-Location)> "\n')
        file.write("}\n\n")
        file.write("function Get-EnvSafe {\n")
        file.write('    param([string]$Name, [string]$Default = "")\n')
        file.write('    if (Test-Path "Env:\\${Name}") {\n')
        file.write('        return (Get-Item "Env:\\${Name}").Value\n')
        file.write("    }\n")
        file.write("    return $Default\n")
        file.write("}\n\n")


class PowerShellEnvironmentSetupWriter(EnvironmentSetupWriter):
    """
    PowerShell environment setup writer.
    """

    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write PowerShell environment setup code.

        Args:
            file: File object to write to
        """
        file.write("function Set-ProdEnvironment {\n")
        for key, value in self.env_variables.items():
            safe_value = value.replace("'", "''")
            file.write(f"    $env:{key} = '{safe_value}'\n")
        file.write("}\n\n")
        file.write("Set-ProdEnvironment\n\n")
        file.write("# Define software aliases\n")


class PowerShellSoftwareAliasWriter(SoftwareAliasWriter):
    """
    PowerShell software alias writer.
    """

    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write PowerShell software aliases.

        Args:
            file: File object to write to
            **kwargs: Should include 'software_items' and 'prod_name'
        """
        super().write(file, **kwargs)  # Call base class validation
        self.prod_name = kwargs["prod_name"]
        software_items = kwargs["software_items"]

        for item in software_items:
            if ":" in item:
                software_name, version = item.split(":", 1)
                self._write_software_function(file, software_name)
                self._write_help_function(file, software_name, version)

    def _write_software_function(
        self, file: TextIO, software_name: str
    ) -> None:
        """
        Write PowerShell software launcher function.

        Args:
            file: File object to write to
            software_name: Name of the software
            version: Version of the software
        """
        file.write(f"function global:{software_name} {{\n")
        file.write("    param(\n")
        file.write("        [Parameter(ValueFromRemainingArguments=$true)]\n")
        file.write("        [string[]]$Params\n")
        file.write("    )\n")

        # Add verbose mode handling
        file.write("    $verboseFlag = ''\n")
        file.write("    if ($script:VERBOSE) {\n")
        file.write(f'        Write-Host "Launching {software_name} with the command {self._command(software_name)}" -ForegroundColor Cyan\n')
        file.write("        $verboseFlag = '-v'\n")
        file.write("    }\n\n")

        file.write(f"    $rezCmd = \"{self._command(software_name)}\"\n")
        file.write("    if ($Params) {\n")
        file.write('        $rezCmd += " " + ($Params -join " ")\n')
        file.write("    }\n")
        file.write("    Invoke-Expression $rezCmd\n")
        file.write("}\n\n")

    def _write_help_function(
        self, file: TextIO, software_name: str, version: str
    ) -> None:
        """
        Write PowerShell help function for software.

        Args:
            file: File object to write to
            software_name: Name of the software
            version: Version of the software
        """
        file.write(f"# Help for {software_name}\n")
        file.write(f"function global:Help-{software_name} {{\n")
        usage_msg = (
            f'    Write-Host "Usage: {software_name} [options]" -ForegroundColor Cyan\n'
        )
        file.write(usage_msg)
        launch_msg = (
            f'    Write-Host "Launches {software_name} version {version} with Rez" '
            f"-ForegroundColor Cyan\n"
        )
        file.write(launch_msg)
        package_msg = (
            f'    Write-Host "For package options, use: {software_name} '
            f'--packages pkg1 pkg2" -ForegroundColor Cyan\n'
        )
        file.write(package_msg)
        file.write("}\n\n")


class PowerShellWelcomeMessageWriter(WelcomeMessageWriter):
    """
    PowerShell welcome message writer.
    """

    # String constants to avoid duplication
    _BLOCK_BEGIN = "    if ($script:VERBOSE) {\n"
    _BLOCK_END = "    }\n"

    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write PowerShell welcome message.

        Args:
            file: File object to write to
            **kwargs: Should include 'prod_name' and 'software_items'
        """
        prod_name = kwargs["prod_name"]
        software_items = kwargs["software_items"]

        file.write(f"$env:prodName = '{prod_name}'\n")
        file.write('Write-Host "==========================================" -ForegroundColor Cyan\n')
        file.write('Write-Host "PRODUCTION ENVIRONMENT ACTIVATED: " -NoNewline -ForegroundColor Cyan\n')
        file.write(f'Write-Host "{prod_name}" -ForegroundColor Green\n')
        file.write('Write-Host "==========================================" -ForegroundColor Cyan\n')
        file.write("Write-Host \"Type 'exit' to leave the production environment`n\" -ForegroundColor DarkGray\n\n")
        file.write('Write-Host "Available Software Tools:" -ForegroundColor Cyan\n')

        if not software_items:
            file.write('Write-Host "No software configured for this production" -ForegroundColor Yellow\n')

        for item in software_items:
            if ":" in item:
                software_name, version = item.split(":", 1)
                rez_command = f"rez env {software_name}-{version} -- {software_name}"
                file.write(self._BLOCK_BEGIN)
                file.write(
                    f'        Write-Host "* {software_name} (version {version}) " -ForegroundColor White -NoNewline\n'
                )
                file.write(
                    f'        Write-Host "({rez_command})" -ForegroundColor DarkGray\n'
                )
                file.write("    } else {\n")
                file.write(
                    f'        Write-Host "* {software_name} (version {version})" -ForegroundColor White\n'
                )
                file.write(self._BLOCK_END)
            else:
                file.write(f'Write-Host "* {item}" -ForegroundColor White\n')


class BashScriptGenerator(ShellScriptGenerator):
    """
    Bash script generator implementation.
    """

    def _create_header_writer(self) -> HeaderWriter:
        return BashHeaderWriter()

    def _create_env_setup_writer(
        self, env_variables: Dict[str, str]
    ) -> EnvironmentSetupWriter:
        return BashEnvironmentSetupWriter(env_variables)

    def _create_software_alias_writer(self) -> SoftwareAliasWriter:
        return BashSoftwareAliasWriter()

    def _create_welcome_msg_writer(self) -> WelcomeMessageWriter:
        return BashWelcomeMessageWriter()

    def _get_file_extension(self) -> str:
        return ".sh"


class BashHeaderWriter(HeaderWriter):
    """
    Bash script header writer.
    """

    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write the Bash script header.

        Args:
            file: File object to write to
            **kwargs: Should include 'prod_name'
        """
        prod_name = kwargs["prod_name"]

        file.write("#!/bin/bash\n")
        file.write(PROD_CLI_HEADER)
        file.write(PROD_CLI_INTERACTIVE_SETUP)

        # Add verbose mode handling
        file.write("# Check for verbose mode\n")
        file.write('if [ "$VERBOSE" = "1" ]; then\n')
        file.write('    echo "Verbose mode enabled"\n')
        file.write("fi\n\n")

        self._write_exit_function(file)
        self._write_prompt_setup(file, prod_name)

    def _write_exit_function(self, file: TextIO) -> None:
        """
        Write Bash exit function override.

        Args:
            file: File object to write to
        """
        file.write("function original_exit() {\n")
        file.write('    builtin exit "$@"\n')
        file.write("}\n\n")

        file.write("function exit() {\n")
        file.write(
            '    printf "\\033[32mExited production environment \'%s\'\\033[0m\\n" "$PROD"\n'
        )
        file.write('    original_exit "$@"\n')
        file.write("}\n\n")

    def _write_prompt_setup(self, file: TextIO, prod_name: str) -> None:
        """
        Write Bash prompt setup.

        Args:
            file: File object to write to
            prod_name: Name of the production
        """
        file.write("\n# Set custom prompt\n")
        file.write(f'export PS1="[PROD:{prod_name}] \\w> "\n\n')


class BashEnvironmentSetupWriter(EnvironmentSetupWriter):
    """
    Bash environment setup writer.
    """

    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write Bash environment setup code.

        Args:
            file: File object to write to
        """
        for key, value in self.env_variables.items():
            safe_value = value.replace("'", "'\\''")
            file.write(f"export {key}='{safe_value}'\n")

        # Add verbose mode output
        file.write("\n# Display environment variables in verbose mode\n")
        file.write('if [ "$VERBOSE" = "1" ]; then\n')
        file.write('    echo "Environment variables set:"\n')
        file.write("    env | sort\n")
        file.write("fi\n")

        file.write("\n# Define software aliases\n")


class BashSoftwareAliasWriter(SoftwareAliasWriter):
    """
    Bash software alias writer.
    """

    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write Bash software aliases.

        Args:
            file: File object to write to
            **kwargs: Should include 'software_items' and 'prod_name'
        """
        super().write(file, **kwargs)  # Call base class validation
        self.prod_name = kwargs["prod_name"]
        software_items = kwargs["software_items"]

        for item in software_items:
            if ":" in item:
                software_name, version = item.split(":", 1)
                self._write_software_function(file, software_name)
                self._write_help_function(file, software_name, version)

    def _write_software_function(
        self, file: TextIO, software_name: str
    ) -> None:
        """
        Write Bash software launcher function.

        Args:
            file: File object to write to
            software_name: Name of the software
            version: Version of the software
        """
        file.write(f'function {software_name}() {{\n')
        file.write(f'    cmd="{self._command(software_name)}"\n')
        file.write('    local verboseFlag=""\n')
        file.write('    if [ "$VERBOSE" = "1" ]; then\n')
        file.write(f'        echo "Launching {software_name} with the command {self._command(software_name)}" >&2\n')
        file.write('        verboseFlag="-v"\n')
        file.write('    fi\n\n')
        file.write(f'    {self._command(software_name)} "$@"\n')
        file.write("}\n")
        file.write(f"export -f {software_name}\n\n")

    def _write_help_function(
        self, file: TextIO, software_name: str, version: str
    ) -> None:
        """
        Write Bash help function for software.

        Args:
            file: File object to write to
            software_name: Name of the software
            version: Version of the software
        """
        file.write(f"# Help for {software_name}\n")
        file.write(f"function Help-{software_name}() {{\n")
        file.write(f'    echo "Usage: {software_name} [options]"\n')
        file.write(f'    echo "Launches {software_name} version {version} with Rez"\n')
        file.write(
            f'    echo "For package options, use: {software_name} --packages pkg1 pkg2"\n'
        )
        file.write("}\n")
        file.write(f"export -f Help-{software_name}\n\n")


class BashWelcomeMessageWriter(WelcomeMessageWriter):
    """
    Bash welcome message writer.
    """

    def write(self, file: TextIO, **kwargs) -> None:
        """
        Write Bash welcome message.

        Args:
            file: File object to write to
            **kwargs: Should include 'prod_name' and 'software_items'
        """
        prod_name = kwargs["prod_name"]
        software_items = kwargs["software_items"]

        file.write(f"export prodName='{prod_name}'\n")
        file.write("echo\n")
        file.write('printf "==========================================\\n"\n')
        file.write('printf "PRODUCTION ENVIRONMENT ACTIVATED: %s\\n" "$prodName"\n')
        file.write('printf "==========================================\\n"\n')
        file.write("echo\n")
        file.write("printf \"Type 'exit' to leave the production environment\\n\\n\"\n")
        file.write('printf "Available Software Tools:\\n"\n')

        if software_items:
            for item in software_items:
                if ":" in item:
                    software_name, version = item.split(":", 1)
                    rez_command = (
                        f"rez env {software_name}-{version} -- {software_name}"
                    )
                    file.write('    if [ "$VERBOSE" = "1" ]; then\n')
                    file.write(
                        f'        printf "  * {software_name} (version {version}) "\n'
                    )
                    file.write(
                        f'        printf "\\033[90m({rez_command})\\033[0m\\n"\n'
                    )
                    file.write("    else\n")
                    file.write(
                        f'        printf "  * {software_name} (version {version})\\n"\n'
                    )
                    file.write("    fi\n")
                else:
                    file.write(f'printf "  * {item}\\n"\n')
        else:
            file.write('printf "No software configured for this production\\n"\n')


class EnvironmentManager:
    """
    Manages environment variables and interactive shell generation.
    """

    def __init__(self):
        """
        Initialize the environment manager.
        """
        self.logger = get_logger()
        self.current_env = dict(os.environ)
        self.env_variables = {}

    def set_environment_variables(self, variables: Dict[str, str]) -> None:
        """
        Set the environment variables.

        Args:
            variables: Dictionary of environment variables to set
        """
        self.env_variables.update(variables)

        for key, value in variables.items():
            self._set_environment_variable(key, value)
            self.logger.debug(f"Set environment variable: {key}={value}")

    def _set_environment_variable(self, key: str, value: str) -> None:
        """
        Set an environment variable.

        Args:
            key: Environment variable name
            value: Environment variable value
        """
        self.current_env[key] = value
        os.environ[key] = value

    def set_path_variables(self, path_variables: Dict[str, List[str]]) -> None:
        """
        Set up path environment variables.

        Args:
            path_variables: Dictionary of path environment variables to set
        """
        for key, paths in path_variables.items():
            existing_path = self.current_env.get(key, "")
            formatted_paths = self._format_paths(paths)
            separator = os.pathsep
            new_path = existing_path

            for path in formatted_paths:
                norm_path = Path(path).resolve()
                if existing_path and norm_path not in [
                    p.resolve() for p in existing_path.split(separator)
                ]:
                    new_path = f"{path}{separator}{new_path}" if new_path else path

            self._set_environment_variable(key, new_path)
            self.logger.debug(f"Set path variable: {key}={new_path}")

    def _format_paths(self, paths: List[str]) -> List[str]:
        """
        Format paths according to the operating system.

        Args:
            paths: List of paths to format

        Returns:
            List of formatted paths
        """
        formatted_paths = []
        for path in paths:
            path = os.path.expandvars(path)
            if platform.system() == "Windows":
                path = path.replace("/", "\\")
            formatted_paths.append(path)
        return formatted_paths

    def generate_interactive_shell_script(
        self, prod_name: str, software_list: Optional[List[str]] = None
    ) -> str:
        """
        Generate an interactive shell script that sets environment variables
        and defines an 'exit' command to properly exit the production environment.

        Args:
            prod_name: Name of the production
            software_list: Optional list of software items in format "name:version"

        Returns:
            Path to the generated script
        """
        script_generator = self._get_script_generator()
        return script_generator.generate_interactive_script(prod_name, software_list)

    def _get_script_generator(self) -> ShellScriptGenerator:
        """
        Get the appropriate script generator for the current operating system.

        Returns:
            Script generator instance
        """
        if platform.system() == "Windows":
            return PowerShellScriptGenerator(self.env_variables)
        else:
            return BashScriptGenerator(self.env_variables)

    def source_interactive_shell(self, script_path: str, verbose: bool = False) -> None:
        """
        Source the interactive shell script to enter a subshell with the production environment.
        This function will start a new interactive shell and only return when the user exits that shell.

        Args:
            script_path: Path to the interactive shell script
            verbose: Whether to enable verbose mode
        """

        try:
            self.logger.debug(f"Starting interactive shell with script: {script_path}")

            if platform.system() == "Windows":
                ps_path = "powershell.exe"
                if verbose:
                    verbose_args = f"-Command \"& {{$VerbosePreference = 'Continue'; . '{script_path}'}}\""
                    cmd = f"{ps_path} -NoLogo -NoExit -ExecutionPolicy Bypass {verbose_args}"
                else:
                    cmd = f'{ps_path} -NoLogo -NoExit -ExecutionPolicy Bypass -File "{script_path}"'
                self.logger.debug(f"Running command: {cmd}")
                os.system(cmd)
            else:
                if verbose:
                    os.system(f'VERBOSE=1 bash --rcfile "{script_path}"')
                else:
                    os.system(f'bash --rcfile "{script_path}"')

            self.logger.debug("Interactive shell exited")
        except Exception as e:
            self.logger.error(f"Failed to source interactive shell script: {e}")
